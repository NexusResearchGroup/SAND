import java.io.*;	import java.net.*;import java.text.DecimalFormat;public class NetworkDynamics {	String inputFile;	public URL url;	public int endyear;	double Max;				private int landusetype   =   0;	private float triprate=(float)1.0;	private float  vot       =   (float) 10.0 ;		//var6:  value of time	private float coeff      =     (float)0.05*60;	//    var10:coeff in trip distribution (friction factor)	private float theta=(float)0.2*60;	private float peakRatio=(float)0.15;	public float aver=(float)500;		private int tPeriod = 1;    ////var22: time period of evolution			/////////////////////////////////////////////////////////////   Components of Network dynamix	///////////////////////////////////////////////////////////// 	DirectedGraph dg;	//Automata ca;	TGeneration tgen;	TDistribution tdist;	DijkstrasAlgo dalgo;	TAssignment tassign;	/////////////////////////////////////////////////////////////   Components of Network dynamix	///////////////////////////////////////////////////////////// 		///////////////////////////////////////////////////////////////    Output variables 	/////////////////////////////////////////////////////////////// 	FloatStack  Speed[][];	FloatStack  Volume[][];	FloatStack  VCR[][];		FloatStack	Capacity[];		float daily_vkt=0;	float daily_vht=0;	int peakTripsProduced=0;	float daily_toll=0;	float aver_trip_length=0;	float aver_trip_time=0;	float totallanekilo=0;	float lanekiloadded=0;		float access_jobs=0;		Demo demo;	///////////////////////////////////////////////////////////////    Output variables 	/////////////////////////////////////////////////////////////// 			// Constructors		public NetworkDynamics(float  vars[]) {		setVariables( vars );/////CALCULATE MAX		{		double MaxX, MaxY;		double MinX, MinY;					MaxX = dg.XCoordinate(1);		MinX = dg.XCoordinate(1);		for(int i=2; i<=dg.Vertices(); i++) {			if(dg.XCoordinate(i) < MinX)				MinX = dg.XCoordinate(i);			if(dg.XCoordinate(i) > MaxX)				MaxX = dg.XCoordinate(i);		}			MaxY = dg.YCoordinate(1);		MinY = dg.YCoordinate(1);		for(int i=2; i<=dg.Vertices(); i++) {			if(dg.YCoordinate(i) < MinY)				MinY = dg.YCoordinate(i);			if(dg.YCoordinate(i) > MaxY)			MaxY = dg.YCoordinate(i);		}			// The distance between farthest points in the graph along x or y direction(we dont care the direction) 		Max = ((MaxX+MinX)>(MaxY+MinY)) ? (MaxX+MinX) : (MaxY+MinY);		Max++;	}	}	public NetworkDynamics( float  vars[], URL url,  String inputFileName) throws IOException{						inputFile = inputFileName;					setVariables( vars );			this.url =url;/////SET UP DIRECTEDGRAPH					//System.out.print("here speed1="+speed1+"\n");						dg = new DirectedGraph(url, inputFile,landusetype,triprate,coeff,theta,peakRatio,aver);			/////CALCULATE MAX			{			double MaxX, MaxY;			double MinX, MinY;							MaxX = dg.XCoordinate(1);			MinX = dg.XCoordinate(1);			for(int i=2; i<=dg.Vertices(); i++) {				if(dg.XCoordinate(i) < MinX)					MinX = dg.XCoordinate(i);				if(dg.XCoordinate(i) > MaxX)					MaxX = dg.XCoordinate(i);			}					MaxY = dg.YCoordinate(1);			MinY = dg.YCoordinate(1);			for(int i=2; i<=dg.Vertices(); i++) {				if(dg.YCoordinate(i) < MinY)					MinY = dg.YCoordinate(i);				if(dg.YCoordinate(i) > MaxY)				MaxY = dg.YCoordinate(i);			}					// The distance between farthest points in the graph along x or y direction(we dont care the direction) 			Max = ((MaxX+MinX)>(MaxY+MinY)) ? (MaxX+MinX) : (MaxY+MinY);			Max++;		}													}			public NetworkDynamics( float  vars[], URL url,  String inputFileName, Demo demo) throws IOException{						this.demo=demo;			this.url =url;			inputFile = inputFileName;					setVariables( vars );/////SET UP DIRECTEDGRAPH		  			//System.out.print("vars[0]="+vars[0]+"\tspeed1="+speed1+"\n");			dg = new DirectedGraph(url, inputFile,landusetype,triprate,coeff,theta,peakRatio,aver);					/////CALCULATE MAX			{			double MaxX, MaxY;			double MinX, MinY;							MaxX = dg.XCoordinate(1);			MinX = dg.XCoordinate(1);			for(int i=2; i<=dg.Vertices(); i++) {				if(dg.XCoordinate(i) < MinX)					MinX = dg.XCoordinate(i);				if(dg.XCoordinate(i) > MaxX)					MaxX = dg.XCoordinate(i);			}					MaxY = dg.YCoordinate(1);			MinY = dg.YCoordinate(1);			for(int i=2; i<=dg.Vertices(); i++) {				if(dg.YCoordinate(i) < MinY)					MinY = dg.YCoordinate(i);				if(dg.YCoordinate(i) > MaxY)				MaxY = dg.YCoordinate(i);			}					// The distance between farthest points in the graph along x or y direction(we dont care the direction) 			Max = ((MaxX+MinX)>(MaxY+MinY)) ? (MaxX+MinX) : (MaxY+MinY);			Max++;		}												}	///////	/// End of constructors		private void setVariables(float vars[]) {		landusetype=(int)vars[0];		triprate=vars[1];		vot=vars[2];		coeff=vars[3];		theta=vars[4];		peakRatio=vars[5];	}		public void NetworkDynamix( URL url,float vars[]){				int vertices, edges;		double Max=this.Max ;				//demo.dp.showStatus.setText("Network initializing...");		//demo.dp.showStatus.repaint() ;				setVariables( vars);				vertices = dg.Vertices();		edges = dg.Edges();				///// intitalize output variables		Speed = new FloatStack[tPeriod+1][vertices];		Volume = new FloatStack[tPeriod+1][vertices];		VCR = new FloatStack[tPeriod+1][vertices];		Capacity = new FloatStack[vertices];		//avgSpeed = new float[tPeriod+1];		//varianceSpeed = new float[tPeriod+1];		//avgVolume = new float[tPeriod];		//varianceVolume = new float[tPeriod];		//////////////////////////////////////////////////		System.out.print("here!\n");					//////CALL AUTOMATA//////////////		//		ca = new Automata();//		ca.automata(url,dg);//		//		System.out.println("End of land use allocation");				tgen=new TGeneration(dg);		dalgo=new DijkstrasAlgo(dg);		tdist=new TDistribution(dg);		tassign=new TAssignment(dg);		//		System.out.print("\tTrip generation multiplier= "+tgen.trip_gen_mutiplier+"\n" );		//		System.out.print("\tFriction factor= "+tdist.coeff /60+"\n");//		if(dg.linkinfofile=="Linkinfo_2005n_nobridge.txt")System.out.print("Bridge links have been taken off.\n");		endyear=tPeriod+1;		for(int p=0; p<vertices; p++) {			Speed[0][p] = new FloatStack( dg.NoofLinks(p+1) );			for(int q=0; q<dg.NoofLinks(p+1); q++) {				float temp=dg.Speed( p+1,q+1);								Speed[0][p].push(dg.Speed( p+1,q+1) );				}			}						for(int p=0; p<vertices; p++) {			Volume[0][p] = new FloatStack( dg.NoofLinks(p+1) );			VCR[0][p] = new FloatStack( dg.NoofLinks(p+1) );			for(int q=0; q<dg.NoofLinks(p+1); q++) {								Volume[0][p].push(0);					VCR[0][p].push(0);				}			}									int tPeriod=0;//number of five-year simulation periods		endyear=tPeriod+1;				for (int k=0;k<=tPeriod;k++){			System.out.print("\n");			System.out.print("**Trip Generation started...\n");				//dp.showStatus.setText("Trip Generation started...");			tgen.tripGeneration(dg);			System.out.print("**Shortest path finding...\n");			//demo.dp.showStatus.setText("Shortest path finding...");			dalgo.dijkstrasalgo(dg,dg.genLinkTime() );						System.out.print("**Trip Distribution started...\n");				//demo.dp.showStatus.setText("Trip Distribution started...");				tdist.tripDistribution(dg,tgen,dalgo);			//tdist.printODMatrix(dg);			//			boolean fixed=true;//			if (fixed){//				System.out.print("The program is loading the fixed trip table...\n");//				dg.readODMatrix();//			}//			else{//				System.out.print("The program is allocating o-d trips...\n");//				tdist.tripDistribution(dg,tgen,dalgo);//			}//			//tdist.printODMatrix(dg);////			//if((dg.baseyear+t)==1000){//			//	tdist.printODMatrix(dg);//			//	tdist.printODCost( dg,dalgo);//			//}						System.out.print("**Traffic Assignment started...\n");				//demo.dp.showStatus.setText("Traffic Assignment started...");				tassign.trafficassignment(dg,dalgo);									System.out.print("--------------------------------------------------------------------------------------------------\n");					System.out.print("\n");						for(int p=0; p<dg.vertices; p++) {				Speed[k+1][p] = new FloatStack( dg.NoofLinks(p+1) );				Volume[k+1][p] = new FloatStack( dg.NoofLinks(p+1) );				VCR[k+1][p] = new FloatStack( dg.NoofLinks(p+1) );				for(int q=0; q<dg.NoofLinks(p+1); q++) {					Speed[k+1][p].push(dg.Speed(p+1, q+1));						 Volume[k+1][p].push(dg.Volume(p+1,q+1));					 VCR[k+1][p].push(dg.Volume(p+1,q+1)/dg.Capacity(p+1, q+1));									}			}		}										for(int p=0; p<vertices; p++) {			Capacity[p] = new FloatStack( dg.NoofLinks(p+1) );			for(int q=0; q<dg.NoofLinks(p+1); q++) {								Capacity[p].push(dg.Capacity(p+1, q+1));				}			}					//Calculate MOE's after the last iteration		//daily vkt, yearly vht		daily_vht=0;		daily_vkt=0;		for(int p=0; p<dg.edges; p++) {			daily_vht+=dg.link_info [p][7]*dg.link_info [p][9]/peakRatio;			daily_vkt+=dg.link_info[p][4]*dg.link_info [p][7]/peakRatio;		}					//total trips		peakTripsProduced=(int)tgen.totaltrips;				//average trip length, average trip time		aver_trip_length=(daily_vkt*peakRatio)/peakTripsProduced;		aver_trip_time=(daily_vht*peakRatio)/peakTripsProduced;				//total lane.kilometers, lane.kilometers added		totallanekilo=0;		lanekiloadded=0;		for(int p=0; p<dg.edges; p++) {			totallanekilo+=dg.link_info [p][4]*dg.link_info [p][6]/1200;			if(dg.link_info [p][6]>dg.originalLinkInfo[p][6]){				lanekiloadded+=dg.link_info [p][4]*(dg.link_info [p][6]-dg.originalLinkInfo[p][6])/1200;			}			daily_vht+=dg.link_info [p][7]*dg.link_info [p][9]/peakRatio;			daily_vkt+=dg.link_info[p][4]*dg.link_info [p][7]/peakRatio;		}							//				//yearly toll revenue		daily_toll=0;		for(int p=0; p<dg.edges; p++) {			daily_toll+=dg.link_info [p][7]*dg.link_info [p][8]/peakRatio;		}							//accessibility to jobs		access_jobs=0;		for (int i=0;i<dg.vertices;i++){			double access=0;			for (int j=0;j<dg.vertices;j++){				access+=dg.node_info[j][4]*Math.exp(-dg.coeff*dalgo.pLabel(i+1, j+1, dg));			}			access_jobs+=access*dg.node_info[i][3];		}									//demo.dp.showStatus.setText("End of travel demand forecasting.");		//demo.dp.showStatus.repaint() ;									}		///  End of networkDynamix																			void writeMe(int intVal, FileOutputStream fout) throws IOException {		String s = Integer.toString(intVal);				for(int i=0; i<s.length(); i++)			fout.write( (int)(    s.charAt(i)   )   );					}		void writeMe(float floatVal, FileOutputStream fout) throws IOException {		String s = Float.toString(floatVal);				for(int i=0; i<s.length(); i++)			fout.write( (int)(    s.charAt(i)   )   );					}									}