import java.io.*;import java.util.Random;import java.net.*;/*automata is completely in first quadrant of the xy plane with its left bottim cellhaving (0, 0) coordinates and top right cell having (size-1, size-1) coordinatesno. of properties of the cells is initialized to 10 unless specified.*/ public class Automata {	public URL url;	public double downtown_x0=-1;	public double downtown_y0=-1;	public int downtownnodeID=-1;		public Automata() {	}		/*		Similar to the nextInt(int n) available in java2. Since this function is not working in my comp		a similar implementation is adopted here		do {					bits = r.nextInt();					val = bits%pop;				} while (bits - val + (pop-1) < 0);  	*/		public void automata(URL url, DirectedGraph dg) {				int landusetype=(int)dg.landusetype;		float aver=1000;				if (landusetype==0){			for (int i=0;i<dg.vertices;i++){				dg.node_info[i][3]=dg.node_info[i][4]=aver;			}						System.out.print("\tUniform distributed workers and jobs allocated.\n");		}		else if (landusetype==1){			float randoms[]=new float[2000];			randoms=dg.randomNumbers(url);			double total1=0;			double total2=0;			int index=0;			for (int i=0;i<dg.vertices;i++){				dg.node_info[i][3] = randoms[index]*aver;				total1+=dg.node_info[i][3];				index++;				dg.node_info[i][4] = randoms[index]*aver;  				total2+=dg.node_info[i][4];				index++;							}						double factor1=aver*dg.vertices/total1;			double factor2=aver*dg.vertices/total2;			for (int i=0;i<dg.vertices;i++){				dg.node_info[i][3] *=factor1; 				dg.node_info[i][4] *=factor2; 			}			System.out.print("\tRandomly distributed workers and jobs allocated.\n");		}		else if(landusetype==2){			double decline_jobs=0.2,decline_workers=0.1;			//later the two coefficients should be related to scale			downtownnodeID=42;						if(dg.vertices==56){				downtown_x0=dg.XCoordinate(downtownnodeID);								downtown_y0=dg.YCoordinate(downtownnodeID);			}			else{				downtown_x0=(dg.maxX()+dg.minX())/2;								downtown_y0=(dg.maxY()+dg.minY())/2;			}						double total1=0,total2=0;			for (int i=0;i<dg.vertices;i++){				double distance=0.2*Math.sqrt(Math.pow(dg.XCoordinate(i+1)-downtown_x0, 2)+Math.pow(dg.YCoordinate(i+1)-downtown_y0, 2));				dg.node_info[i][4] = Math.exp(-decline_jobs*distance); 				total1+=dg.node_info[i][4];				dg.node_info[i][3] = Math.exp(decline_workers*distance); 				total2+=dg.node_info[i][3];			}						double factor1=aver*dg.vertices/total1;			double factor2=aver*dg.vertices/total2;						for (int i=0;i<dg.vertices;i++){				dg.node_info[i][4] *=factor1; 				dg.node_info[i][3] *=factor2; 			}			System.out.print("\tBell-shaped distributed workers and jobs allocated.\n");		}		}			}