import java.io.*;//import java.util.Random;import java.net.*;import java.text.*;public class DirectedGraph {	  public int edges = 0, vertices=0;//number of established links and nodes	  public URL url;	  	  //Parameters in travel demand models	  public double vot=10;//$ per hour	  public double intracost=5.0/60.0;//hour	  public int landusetype=0;	  public double triprate=1.0;	  public double coeff = 0.05*60;// coefficent in friction function /hour	  public double theta=0.2*60;//0.2 is for travel time in minutes; .2*60 is for hours	  //The dispersion parameter theta is set at 0.2, following Leurent's (1995) work on 	  //case studies in the Paris metropolitan area. This means that if one route is shorter by five       //minutes than another, then approximately three out of four drivers will choose the first road. 	 public double peakratio=0.15;	  public double INF= 1.0E50;	  public float threshold_tt=(float)10;	  	  	  ///Data	  public double node_info[][];	  int node_attributes=5;	  //0-node ID	  //1-centroid x-coordinate	  //2-centroid y-coordinate	  //3-number of available workers	  //4-number of available jobs	//**Network***		  public double link_info[][];//brackets:1-link index; 2-attribute index 	  //the original network is a grid network of trails	  //roads at higher speeds are added incrementally	  int link_attributes=11;	  	  ///link attributes	  //0-link ID (from 1)	  //1-Origin centroid ID	  //2-Destination centroid ID	  //3-built year	  //4-length	  //5-free flow speed	  //6-capacity	  //7-traffic flow	  //8-toll rate	  //9-congested travel time	  //10-generalized travel time		  //Additional network information	  private int nooflinks[], endnodenumbers[][];	  public int linkID[][],linklength[][],linkspeed;	  public int endnodeTolinks[][];//each IntStack stores links which end at a specific node	  public int oppolink[];	  double nodeCoord[][];	  	  public String networkinfofile="";	  //public String nodeCoorfile="";		  public float ODMatrix[][];		  FloatStack Capacity[];	  public double originalLinkInfo[][];	  public double originalNodeInfo[][];	///////// Constructor /////////		public DirectedGraph(URL url, String filename,int landusetype,float triprate,float coeff,float theta,float peakRatio, float aver) throws IOException{		this.url =url;		ReadANumber read = new ReadANumber();		InputStream fin = null;		networkinfofile=filename;				this.landusetype=landusetype;		this.triprate=triprate;		this.vot=vot;		this.coeff=coeff;		this.theta=theta;		this.peakratio=peakRatio;					//load network information			//load node coordinate information		try {			fin = new URL(url, networkinfofile).openStream();		} catch(FileNotFoundException e) {			System.out.println("From DirectedGraph class: Load network file failed!!!!");			return;		}		vertices = read.readint(fin);		//System.out.print("vertices= "+vertices+"\n");				node_info=new double[vertices][node_attributes];		for (int e=0;e<vertices;e++){			for (int k=0;k<node_attributes;k++){				node_info[e][k]=0;			}		}				for (int i=0;i<vertices;i++)		{			node_info[i][0] = i+1;	//node ID;			node_info[i][1] = read.readfloat(fin);    //read X coordinate; unit in meters;			node_info[i][2] = read.readfloat(fin);//read Y coordinate; 			node_info[i][3] = read.readfloat(fin);// read #workers			node_info[i][4] = read.readfloat(fin);// read #jobs			if(node_info[i][3]<0) node_info[i][3]= aver;			if(node_info[i][4]<0) node_info[i][4]= aver;						if (read.end == -1)			{break;}		}		System.out.print("Node information loaded.\n");		//load link info				edges = read.readint(fin);				//System.out.print("edges= "+edges+"\n");		link_info=new double[edges][link_attributes];		for (int e=0;e<edges;e++){			for (int k=0;k<link_attributes;k++){				link_info[e][k]=0;			}		}		for (int i=0;i<edges;i++)		{			for (int k=0;k<link_attributes;k++){				link_info[i][k]=read.readfloat(fin);				if (read.end == -1)				{break;}			}		}		fin.close();		System.out.print("Link information loaded.\n");						//ODMatrix		ODMatrix=new float [vertices][vertices];				for (int i=0; i<vertices;i++){			for (int j=0;j<vertices;j++){				ODMatrix[i][j]=0;			}		}		//extract additional network information					//sort links ascendingly according to start nodes first and end nodes then		double templinkinfo[]=new double[link_attributes];		for (int e1=0;e1<edges-1;e1++){			for(int e2=e1+1;e2<edges;e2++){				if(link_info[e1][1]>link_info[e2][1] || (link_info[e1][1]==link_info[e2][1] && link_info[e1][2]>link_info[e2][2])){					for (int k=0;k<link_attributes;k++){						templinkinfo[k]=link_info[e1][k];						link_info[e1][k]=link_info[e2][k];						link_info[e2][k]=templinkinfo[k];					}				}			}		}		for (int e=0;e<edges;e++){			link_info[e][0]=e+1;		}		//nooflinks		nooflinks = new int[vertices];		for(int i=0;i<vertices;i++){			nooflinks[i]=0;		}		for (int i=0;i<edges;i++){			nooflinks[(int)link_info[i][1]-1]++;		}				//end node numbers		endnodenumbers = new int[vertices][];		linkID=new int[vertices][];		for(int i=0;i<vertices;i++){			endnodenumbers[i] = new int[nooflinks[i]];			linkID[i] = new int[nooflinks[i]];			for (int j=0;j<nooflinks[i];j++){				endnodenumbers[i][j]=linkID[i][j]=0;			}		}				int preStartNode=-1,linkindex=0;		for (int i=0;i<edges;i++){			int startNode=(int)(link_info[i][1]);			int endNode=(int)(link_info[i][2]);			int linkid=i+1;						if(startNode<1)System.out.print("wrong!");			if(startNode==preStartNode){								endnodenumbers[startNode-1][linkindex]=endNode;				linkID[startNode-1][linkindex]=linkid;				linkindex++;			}			else{				preStartNode=startNode;				linkindex=0;				endnodenumbers[startNode-1][linkindex]=endNode;				linkID[startNode-1][linkindex]=linkid;				linkindex++;							}		}						//endnode to links		int max=100;		endnodeTolinks=new int[vertices][max];		for (int i=0;i<vertices;i++){			endnodeTolinks[i][0]=0;			//endnodeTolinks[i] stores the links who end at the same node (i+1)			//endnodeTolinks[i][0] is used to record the number of links			//the link IDs are stored in endnodeTolinks[i][1], [i][2]...						for(int j=1;j<max;j++){				endnodeTolinks[i][j]=-1;			}		}				for (int i=0;i<edges;i++){			int endnode=(int)link_info[i][2];			endnodeTolinks[endnode-1][0]++;			endnodeTolinks[endnode-1][endnodeTolinks[endnode-1][0]]=i+1;//store linkIDs which start from 1		}				//opposite links		oppolink = new int[edges];		int nooflink;		boolean oppofound;		int dNodeID;		for (int i=0;i<edges;i++)		{			oppofound=false;			dNodeID = (int)link_info[i][2];			nooflink=nooflinks[dNodeID-1];			for (int j=0;j<nooflink;j++)			{				if (((int)link_info[i][1]) == ((int)link_info[(linkID[dNodeID-1][j]-1)][2]))				{					oppolink[i]=linkID[dNodeID-1][j];					oppofound = true;				}			}			if (oppofound == false)			{				oppolink[i]=0;			}		}				//Capacity		Capacity = new FloatStack[vertices];		for(int i=0; i<vertices; i++) {			Capacity[i] = new FloatStack(nooflinks[i]);			for(int j =0; j<nooflinks[i]; j++) {				Capacity[i].push(Capacity(i+1, j+1)); 			}		}		//Keep original link information		originalLinkInfo=new double[edges][link_attributes];		for (int i=0;i<edges;i++){			for (int k=0;k<link_attributes;k++){				originalLinkInfo[i][k]=link_info[i][k];			}		}		originalNodeInfo=new double[vertices][node_attributes];		for (int i=0;i<vertices;i++){			for (int k=0;k<node_attributes;k++){				originalNodeInfo[i][k]=node_info[i][k];			}		}	}		public void updateLinkInfo(){		for (int i=0;i<edges;i++){			  //4-length			  //5-free flow speed			  //6-capacity			  //7-traffic flow			  //8-toll rate			  //9-congested travel time			  //10-generalized travel cost			if(link_info[i][6]==0)link_info[i][9]=link_info[i][4]/link_info[i][5];			else				link_info[i][9]=(link_info[i][4]/link_info[i][5])*(1+0.15*Math.pow((link_info[i][7]/link_info[i][6]),4));			if (link_info[i][9]>threshold_tt)link_info[i][9]=(float)threshold_tt;			link_info[i][10]=link_info[i][9]+link_info[i][8]/vot;		}		}//	////// a class used for reading numbers from the file.  this class is written in order to reduce the redundancy of the code//	////// either an int or a float can be read	class ReadANumber{				public int end;				ReadANumber() {			end = 0;		}				int readint(InputStream f)			throws IOException		 {			String msg = "";			int i;			do {				i=f.read();				//if(i != -1 && i != 13  && i!=32 && i!=9 )				if(i>47 && i<58 || i==(int)'.'|| i==(int)'-')				//////  32 ---- space, 13 ----- new Line				msg += (char)i;								//System.out.print("\tmsg="+msg);			} while((i>47 && i<58 ||i==(int)'.'|| i==(int)'-')&&i!=(int)';');			//while(i==(int)';');			end = i;					try {				if(msg != null)  {					//i = Integer.parseInt(msg);					//return( i );					if(msg.charAt( 0)=='-')return(-1*Integer.parseInt(msg.substring( 1)));					else return(Integer.parseInt(msg) );				}				else					return ( 0 );			}	catch(NumberFormatException e) {				System.out.println("NumberFormatException integer.");				return ( 0 );			}		}								float readfloat(InputStream f) 			throws IOException		{			String msg = "";			int i;						do {								i = f.read();				//System.out.print("\ti="+i);				//if(i != -1 && i != 13 && i != 32 && i!=9 && i!=10)				if(i>47 && i<58 || i==(int)'.' ||i=='-')				msg += (char)i;			} while(i>47 && i<58 || i==(int)'.'||i=='-');						end = i;					try {				if(msg.charAt( 0) != 0)  {					if(msg.charAt( 0)=='-')return(-1*Float.valueOf(msg.substring( 1)).floatValue());					else return( Float.valueOf(msg).floatValue() );				}					else					return ( 0 );			}	catch(NumberFormatException e) {				System.out.println("NumberFormatException float");				return (0);			}		}			}//	///////////////////////    End of ReadANumber class	public int Edges() {		return edges;	}			public int Vertices(){		return vertices;	}	public int NoofLinks(int cellNumber) {      ////// NodeNumber  (1, 2, 3, ........ vertices)		if(cellNumber > vertices || cellNumber <1) {			System.out.println("Invalid argument in NoofLinks function in graph class.");			return ( 0 );		}		else			return(nooflinks[cellNumber-1]);	}			//// EndNodeNumbers argument are first argument:  node number (1,2,3,....... vertices)	/// second argument:  (1,2,3...... nooflinks[first argument -1] = NoofLinks(first argument))		public int EndNodeNumbers(int NodeNumber, int jthLinkedNode) {				if (   (  NodeNumber<=vertices  &&  NodeNumber>=1 )   && (  jthLinkedNode <= nooflinks[NodeNumber-1]  &&   jthLinkedNode>=1  )  ) 			return(  endnodenumbers[NodeNumber-1][jthLinkedNode-1]   );			 else {			System.out.println("!");			return( -100 );		}	}		////// FirstNN, SecondNN = {1,2,3......vertices}   position ={1,2,3....nooflinks[FirstNN-1]}	public int Position_EndNode(int FirstNN, int SecondNN) {		int position =0;		if(Connected(FirstNN, SecondNN) ) {			for(int i=0; i<nooflinks[FirstNN-1]; i++) {				if( endnodenumbers[FirstNN-1][i] == SecondNN)					position = i+1;			}		} else			System.out.println("From Graph class, Position_EndNode: Invalid nodes!!! Nodes are not connected returning a zero value ");							return position;	}						///////////  FirstNN = {1,2,3...vertices}, SecondNN = {node thats connected to FirstNN} = {1,2,3...vertices}	public boolean Connected(int FirstNN, int SecondNN) {		boolean conntd = false; /// true if Second NN is connected to FirstNN  (FNN -----> SNN)		for(int i=0; i<nooflinks[FirstNN-1]; i++) {			if( endnodenumbers[FirstNN-1][i] == SecondNN)				conntd = true;		}				return conntd;	}			public float ODMatrix(int originnum, int destinnum){		return ODMatrix[originnum-1][destinnum-1];			}		public void printODMatrix(){		System.out.print("OD Matrix:\n");		for (int i=0; i<vertices;i++){			for (int j=0;j<vertices;j++){				System.out.print(ODMatrix[i][j]+"\t");			}			System.out.print("\n");			}					}		public double XCoordinate(int nodeID)	{		double x;		x = node_info[nodeID-1][1];		return(x);	}	public double YCoordinate(int nodeID)	{		double y;		y = node_info[nodeID-1][2];		return(y);	}		public double maxX(){		double temp=-1;		for(int i=0;i<vertices;i++){			if(XCoordinate(i+1)>temp)				temp=XCoordinate(i+1);		}				return temp;		}	public double maxY(){		double temp=-1;		for(int i=0;i<vertices;i++){			if(YCoordinate(i+1)>temp)				temp=YCoordinate(i+1);		}				return temp;		}			public double minX(){		double temp=(float)10E10;		for(int i=0;i<vertices;i++){			if(XCoordinate(i+1)<temp)				temp=XCoordinate(i+1);		}				return temp;		}		public double minY(){		double temp=(float)10E10;		for(int i=0;i<vertices;i++){			if(YCoordinate(i+1)<temp)				temp=YCoordinate(i+1);		}				return temp;		}					public float Speed(int FirstNN, int SecondNP) {		if ( (FirstNN >=1 && FirstNN <= vertices) && (SecondNP>=1 && SecondNP <=nooflinks[FirstNN-1]) ) {			int linkid=linkID[FirstNN-1][SecondNP-1];			return((float)(link_info[linkid-1][4]/link_info[linkid-1][9]));		}		else {			System.out.println("From graph class:  Invalid argument passed to Speed Method");			return 0;		}			}		public float Volume(int FirstNN, int SecondNP) {		if ( (FirstNN >=1 && FirstNN <= vertices) && (SecondNP>=1 && SecondNP <=nooflinks[FirstNN-1]) ) {			int linkid=linkID[FirstNN-1][SecondNP-1];			return((float)link_info[linkid-1][7]);		}		else {			System.out.println("From graph class:  Invalid argument passed to Volume Method");			return 0;		}			}	public float Capacity(int FirstNN, int SecondNP) {		if ( (FirstNN >=1 && FirstNN <= vertices) && (SecondNP>=1 && SecondNP <=nooflinks[FirstNN-1]) ) {			int linkid=linkID[FirstNN-1][SecondNP-1];			return((float)link_info[linkid-1][6]);		}		else {			System.out.println("From graph class:  Invalid argument passed to Speed Method");			return 0;		}			}		public double []genLinkTime(){		double temp[]=new double [edges];		for(int i=0;i<edges;i++){			temp[i]=link_info[i][10];		}		return temp;	}	public void savefile(File saveFile)	{		FileOutputStream out= null;		try{			out= new FileOutputStream(saveFile);		}catch(Exception e)		{			System.out.println("Unable to open file");			return;		}		PrintStream psOut=new PrintStream(out);				String outstring="";		outstring += vertices;		outstring +="\n";		for (int i=0;i<vertices;i++){			for (int k=1;k<node_attributes;k++){				outstring +=node_info[i][k];				if(k==4)outstring +="\n";				else outstring +="\t";			}		}				outstring += edges;		outstring +="\n";		for (int i=0;i<edges;i++){			for (int k=0;k<link_attributes;k++){				outstring +=link_info[i][k];				if(k==link_attributes-1)outstring +="\n";				else outstring +="\t";			}		}		outstring +="\n";				psOut.print(outstring);		psOut.close();	}		public float[] randomNumbers(URL url){		InputStream fin=null;		ReadANumber read = new ReadANumber();		float randoms[]=new float[2000];		//random numbers		try {			fin = new URL(url, "randoms.txt").openStream();		} catch(FileNotFoundException e) {			System.out.println("Error!");		}catch(IOException e){					}				int index=0;		for(int i=0;i<2000;i++){			try{				randoms[index]=read.readfloat(fin);				index++;			}catch(IOException e){							}		}		try{			fin.close();		}catch(IOException e){					}				return randoms;	}		public float ffs(int numLanes){		float ffs=0;		if (numLanes==1)ffs=20;		else if(numLanes==2)ffs=50;		else if(numLanes==3)ffs=80;		else if(numLanes==4)ffs=100;		else if(numLanes==5)ffs=110;		else if(numLanes==6)ffs=115;		else if(numLanes==7)ffs=120;		else if(numLanes==8)ffs=120;		return ffs;	}}  